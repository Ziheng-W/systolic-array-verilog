# systolic-array-in-verilog

用verilog实现的脉动阵列。

本代码的目的是用verilog实现可以参数化生成的脉动阵列（包括PE阵列和配套IO），通过eda工具对生成代码进行综合即可估算脉动阵列各部分的资源占用、功耗。

array:
  LUT: 61*n*n (3904 for 8*8, 976 for 4*4)
  reg: 24*n*n (1536 for 8*8, 384 for 4*4)
input(一列):
  LUT: 5*n (40 for 8*8, 20 for 4*4)
  reg: 16*n + logn (131 for 8*8, 66 for 4*4)
output(一方阵):
  LUT: near 2*n*n + logn (131 for 8*8, 34 for 4*4)
  reg: logn (3 for 8*8, 2 for 4*4)
  F7MUX: 64 for 8*8, 0 for 4*4
MUX:
  LUT: 4*n (32 for 8*8, 16 for 4*4)

分块带来的LUT损耗：

一个完整8*8方阵:
  LUT: 4115
  reg: 1801
  F7MUX: 64
四个4*4拼起来:
  LUT: 4264 (103.6%)
  reg: 2072 (115.4%)
  F7MUX: 0    
田字格tiling带来的额外成本可以只考虑L2、MUX的增加，其他消耗只有零头
那么对n*n方阵进行田字格tiling，额外消耗为10*n + 6logn -8.
  LUT: 63*n*n + 10*n + logn -> 63*n*n + 28*n + 4logn -4
  8 拆成 4*4    4115  4264      +3.62%
  16 拆成 8*8   16292 16588     +1.81%
  24            36532 36974     
  32 拆成 16*16 64837 65424     +0.91%
  40            101205 101937
  48            145637 146514
  56            198133 199155
  64 拆成 32*32 258697 259960

to do:

- ~~output略有些bug~~
- 标定各组件体积和fpga资源用量的关系
  - ~~问题：阵列的资源消耗似乎不是O(n2)而是O(n)~~
  - 散装input可以正常综合，封装后的input综合出来是0功耗
  - xilinx这个动不动综合个zero utilization也太抽象了，我是不明白加法器有啥综合不了的
- 整定计算延时、资源、功耗 与 尺寸、数量的关系
- 搞个自动脚本


