写了部分代码的数据分析：
1.
存入的时候需要查找可用的位置（从比方说20个里面找出8个能存东西的地方）
从20个里面取出8个0，LUT消耗是246，gate level是20左右
2.
取出的时候要匹配index，LUT消耗如下：
n 中取出8的LUT:        
 n    24        20      16      12
 LUT  290       241     182     152
 平均 12.083    15.06   11.375  12.66 
 层数 8+-，区别不大 
选16的话，相当于每个pe增加了22.75个LUT。选20的话是30个，有些多了
3.
计算不同pe分比的reg消耗
假设n个pe共用，则需要log2n bit的cache内部地址+16bit数据+5bit index
相当于一个word 有 (log2n + 5 + 16)位
若单个一组，则8个pe需要 8 * 6 * （5+16）= 1008 个寄存器，平均每pe多了7.875个16bit
若4个一组，则需要 2 * 13 * (2 + 5 + 16) = 598 个寄存器，平均每个pe多用了4.67个16bit
若8个一组，则需要 1 * 20 * (3 + 5 + 16) = 480 个寄存器，平均每个pe多了3.75个16bit
所以，pe消耗是8个一组划算。
* 考虑到如果8个pe平分20个word，均摊的LUT不太划算（见上），改为16个的话：
  消耗寄存器为  1 * 16 * (3 + 5 + 16) = 384，平均每pe多用3个16bit。这种情况下，需要多层cache
4.
大致的critical path
level：    8+-           
读： 接收并匹配index，输出并更新 list
写：                  根据list计算可用位置，存储并更新list
level：                   20+-               写reg


一些代码不好写的地方：
我们显然希望可以做到一个周期内先取出一个，然后旧的立刻填上位置，这样总的内容消耗可以比较小，但是时钟会变慢
verilog对类似多维向量的支持不太好，8个端口到时候基本上得手写。


待定：
pe发出申请是在当前周期内给回复，还是下个周期回复？
周期内回复，时钟线基本上必定翻倍（发出申请、收到数据、mac）
下个周期回复的话，一来要加一个16bit寄存器，二来要俩MAC。


